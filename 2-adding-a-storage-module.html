<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>#2: Adding a Storage Module - Get Rusty While Building a Database</title><meta name="description" content="Now that we have got our project up and running, let's actually implement the first piece we'll need to store data. To do that, I made a storage.rs file in my /src directory. This will be our storage module that we'll import later to use. Just like many other&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://nihaocami.github.io/get-rusty-while-building-a-database/2-adding-a-storage-module.html"><link rel="alternate" type="application/atom+xml" href="https://nihaocami.github.io/get-rusty-while-building-a-database/feed.xml"><link rel="alternate" type="application/json" href="https://nihaocami.github.io/get-rusty-while-building-a-database/feed.json"><meta property="og:title" content="#2: Adding a Storage Module"><meta property="og:image" content="https://nihaocami.github.io/get-rusty-while-building-a-database/media/website/rust-db-2.png"><meta property="og:image:width" content="1536"><meta property="og:image:height" content="1536"><meta property="og:site_name" content="Get Rusty While Building a Database"><meta property="og:description" content="Now that we have got our project up and running, let's actually implement the first piece we'll need to store data. To do that, I made a storage.rs file in my /src directory. This will be our storage module that we'll import later to use. Just like many other&hellip;"><meta property="og:url" content="https://nihaocami.github.io/get-rusty-while-building-a-database/2-adding-a-storage-module.html"><meta property="og:type" content="article"><link rel="stylesheet" href="https://nihaocami.github.io/get-rusty-while-building-a-database/assets/css/style.css?v=374b94338f3a686a04ea99b2b03d0db7"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://nihaocami.github.io/get-rusty-while-building-a-database/2-adding-a-storage-module.html"},"headline":"#2: Adding a Storage Module","datePublished":"2024-12-24T10:18-08:00","dateModified":"2024-12-27T09:02-08:00","image":{"@type":"ImageObject","url":"https://nihaocami.github.io/get-rusty-while-building-a-database/media/website/rust-db.png","height":1536,"width":1536},"description":"Now that we have got our project up and running, let's actually implement the first piece we'll need to store data. To do that, I made a storage.rs file in my /src directory. This will be our storage module that we'll import later to use. Just like many other&hellip;","author":{"@type":"Person","name":"Chris Amirani","url":"https://nihaocami.github.io/get-rusty-while-building-a-database/authors/chris-a/"},"publisher":{"@type":"Organization","name":"Chris Amirani","logo":{"@type":"ImageObject","url":"https://nihaocami.github.io/get-rusty-while-building-a-database/media/website/rust-db.png","height":1536,"width":1536}}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template"><header class="top js-header"><a class="logo" href="https://nihaocami.github.io/get-rusty-while-building-a-database/"><img src="https://nihaocami.github.io/get-rusty-while-building-a-database/media/website/rust-db.png" alt="Get Rusty While Building a Database" width="1536" height="1536"></a></header><main class="post"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>#2: Adding a Storage Module</h1><div class="feed__meta content__meta"><a href="https://nihaocami.github.io/get-rusty-while-building-a-database/authors/chris-a/" class="feed__author">Chris Amirani</a> <time datetime="2024-12-24T10:18" class="feed__date">December 24, 2024</time></div></div></header></div><div class="entry-wrapper content__entry"><p>Now that we have got our project up and running, let's actually implement the first piece we'll need to store data. </p><p>To do that, I made a <strong>storage.rs </strong>file in my <strong>/src </strong>directory. This will be our storage <span style="color: #02192b;">module</span> that we'll import later to use. Just like many other programming languages, Rust comes with its own standard library that has many useful tools.</p><p>The one tool we're interested in today is <code>HashMap</code>. You can import it like this:</p><pre class="language-rust"><code>use std::collections::HashMap;</code></pre><p>We use the <strong>use</strong> keyword to import modules. In this case, we are HashMap from collections in standard library.</p><p>A HashMap, as the name suggests, can be used to store things like key/value pair in memory. In addition to that, it has built-in functions like <code>.get()</code><strong> </strong>or <code>.remove()</code> that'll make our life easier.</p><p>Next, we want to define how our data will be stored. For the time being, let's say we want to store key/value pairs in a field called <strong>data</strong>. We can define the structure like this:</p><pre class="language-rust"><code>struct Database {
    data: HashMap&lt;String, String&gt;,
}</code></pre><p>The <strong>struct</strong> keyword tells Rust we want to define a data structure and call it <strong>Database</strong>. In that struct, we want to have a field called <strong>data</strong> which is an instance of the HashMap we imported. This HashMap will have key of type <strong>String </strong>and a value of type <strong>String</strong>. We will change this in the future.</p><p>Now let's implement the basic methods/functions to do some CRUD operations on the database. In Rust, we can define the functionalities a struct can expect, in this case, we want to let Rust know that our <code>Database</code> struct will have 4 functions of <code>new</code><strong>, </strong><code>insert</code><strong>, </strong><code>get</code><strong>, </strong><code>delete</code><strong>.</strong></p><pre class="language-rust"><code>impl Database {
    pub fn new() {}

    pub fn insert() {}

    pub fn get() {}

    pub fn delete(){}
}</code></pre><p>Here we used the <code>impl</code> keyword to define the struct functionalities and defined the skeleton of our functions. The <code>fn</code><strong> </strong>keyword is used to define a function and the <strong>pub</strong> keyword tells Rust this function is public, meaning it can be called outside of the implementation.</p><p>Now let's define the <code>new</code><strong> </strong>function:</p><pre class="language-rust"><code>    pub fn new() -&gt; Self {
        Database {
            data: HashMap::new(),
        }
    }</code></pre><p>This function is simple. The <code>-&gt; Self</code><strong> </strong>is just defining the return type of the function. Since <code>Self</code><strong> </strong>is within the context of <code>Database</code>, the return type will be of type <code>Database</code>. That makes sense since within the function we are initializing an instance of the <code>Database</code> struct and the <code>data</code> field is also getting initialized with new function from <code>HashMap</code>.</p><p>Notice that we don't have to tell Rust explicitly to <strong>return</strong> the initialized Database. In Rust, the last expression is returned by default.</p><p>Now that we can initialize a database, let's enable the "C" in "CRUD". Our <strong>insert</strong> function:</p><pre class="language-rust"><code>    pub fn insert(&amp;mut self, key: String, value: String) {
        self.data.insert(key, value);
    }</code></pre><p><code>self</code> represents the instance of the <code>Database</code> struct on which the method is called. <code>&amp;mut self</code> is a <strong>mutable reference</strong> to the instance, allowing the method to modify its state (in this case, the <code>data</code> field).</p><p>If you used <code>&amp;self</code>, the method would only have read access and couldn't modify the <code>Database</code>. If you used <code>self</code> (without <code>&amp;</code>), the method would <strong>take ownership</strong> of the <code>Database</code>, making it unusable outside the method unless explicitly returned.</p><p><code>self.data</code> accesses the <code>data</code> field of the <code>Database</code> instance, which is a <code>HashMap&lt;String, String&gt;</code>. The <code>insert</code> method of <code>HashMap</code> is called to add or update an entry with the provided <code>key</code> and <code>value</code>.</p><p>For the next two functions, most of what was explained above applies. Here's how they'll look like:</p><pre class="language-rust"><code>    pub fn get(&amp;self, key: &amp;str) -&gt; Option&lt;&amp;String&gt; {
        self.data.get(key)
    }

    pub fn delete(&amp;mut self, key: &amp;str) -&gt; Option&lt;String&gt; {
        self.data.remove(key)
    }</code></pre><p>Notice that they have slightly different return types.</p><p><code>Option&lt;&amp;String&gt;</code> means it returns <code>Some(&amp;String)</code> if the key exists in the <code>HashMap</code>and <code>None</code> if the key does not exist.</p><p>The <code>&amp;String</code> is a <strong>borrowed reference</strong> to the value stored in the <code>HashMap</code>. This avoids ownership transfer. The caller can read the value but cannot modify it. The value remains owned by the <code>HashMap</code>, ensuring safe access while preserving ownership.</p><p>For the delete function, <code>Option&lt;String&gt;</code> means it returns <code>Some(String)</code> if the key exists, containing the <strong>owned value</strong> that was associated with the key and it returns <code>None</code> if the key does not exist.</p><p>The <code>String</code> is <strong>moved out</strong> of the <code>HashMap</code> and returned to the caller. This means the ownership of the value is transferred to the caller. That makes sense since after deletion, the HashMap really shouldn't keep track of/ be associated with the delete value.</p><p>Voila! We're done with implementation of the in memory storage. This will help us manage the stage of our data. In the upcoming blogs we'll see how we can use these functions. </p><p> </p></div><footer class="content__footer"><div class="entry-wrapper"><p class="content__updated">This article was updated on December 27, 2024</p><div class="content__actions"><div class="content__share"><button class="btn--icon content__share-button js-content__share-button"><svg width="20" height="20" aria-hidden="true"><use xlink:href="https://nihaocami.github.io/get-rusty-while-building-a-database/assets/svg/svg-map.svg#share"></use></svg> <span>Share It</span></button><div class="content__share-popup js-content__share-popup"></div></div></div><div class="content__bio bio"><div><h3 class="h4 bio__name"><a href="https://nihaocami.github.io/get-rusty-while-building-a-database/authors/chris-a/" rel="author">Chris Amirani</a></h3><div class="bio__desc"><p>I am full stack software engineer, mainly focused on building the modern web. I started my journey by building in Visual Basic in high school, built agricultural AI systems in college and then fell in love with web development.</p><p>Now I am writing this blog as I learn Rust :)</p></div></div></div></div><nav class="content__nav"><div class="wrapper"><div class="content__nav-inner"><div class="content__nav-next"><a href="https://nihaocami.github.io/get-rusty-while-building-a-database/1-setting-up-a-new-rust-project.html" class="content__nav-link" rel="next"><div><span>Next</span> #1: Setting Up a New Rust Project</div></a></div></div></div></nav></footer></article></main><footer class="footer footer--glued"><div class="wrapper"><div class="footer__copyright"><p>Powered by Publii</p></div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://nihaocami.github.io/get-rusty-while-building-a-database/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://nihaocami.github.io/get-rusty-while-building-a-database/assets/js/scripts.min.js?v=700105c316933a8202041b6415abb233"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>